{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";;;AAAA;;GAEG;AACH,SAAgB,WAAW,CAAgB,OAA0C;IAEpF,OAAO,KAAK,EAAU,KAAS,EAAE,GAAG,IAAI,EAAE,EAAE;QAE3C,MAAM,OAAO,CAAC,KAAY,EAAE,GAAG,IAAI,CAAC,CAAC;QACrC,OAAO,KAAK,CAAA;IACb,CAAC,CAAA;AACF,CAAC;AAPD,kCAOC;AAED;;GAEG;AACH,SAAgB,gBAAgB,CAA6D,GAAG,MAI/F;IAEA,OAAO,KAAK,EAAE,KAAK,EAAE,GAAG,IAAI,EAAE,EAAE;QAE/B,MAAM,OAAO,GAAG,MAAM,CAAC,GAAG,EAA0C,CAAC;QAErE,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,KAAK,YAAY,EAAE,CAAC,EAC9D;YACC,MAAM,OAAO,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,CAAC;SAC9B;QAED,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA;IAC7B,CAAC,CAAA;AACF,CAAC;AAjBD,4CAiBC;AAED;;;GAGG;AACH,SAAgB,cAAc,CAAqD,OAAU,EAC5F,OAA0C;IAG1C,OAAO,OAAO;SACZ,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAM,CAAA;AAClC,CAAC;AAND,wCAMC;AAMD;;;GAGG;AACH,SAAgB,eAAe,CAAqF,OAAU,EAC7H,GAAG,MAAmE;IAGtE,OAAO,OAAO;SACZ,KAAK,CAAC,gBAAgB,CAAC,GAAG,MAAM,CAAC,CAAM,CAAA;AAC1C,CAAC;AAND,0CAMC;AAED,SAAgB,mBAAmB,CAA8E,OAAU,EAC1H,WAA8C,EAC9C,YAAiD;IAGjD,OAAO,GAAG,cAAc,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;IAE/C,IAAI,OAAO,YAAY,KAAK,WAAW,EACvC;QACC,OAAO,eAAe,CAAC,OAAO,EAAE,YAAY,CAAC,CAAA;KAC7C;IAED,OAAO,OAAO,CAAA;AACf,CAAC;AAbD,kDAaC;AAED,SAAgB,kBAAkB,CAA8E,OAAU,EACzH,WAA8C,EAC9C,YAAiD;IAGjD,OAAO,mBAAmB,CAAC,OAAO,EAAE,WAAW,EAAE,YAAY,aAAZ,YAAY,cAAZ,YAAY,GAAI,WAAkB,CAAC,CAAA;AACrF,CAAC;AAND,gDAMC;AAED,kBAAe,kBAAkB,CAAA","sourcesContent":["/**\n * @see https://github.com/sindresorhus/p-tap#ptaptaphandler\n */\nexport function _tapHandler<V extends any>(handler: (value: V, ...argv: any[]) => any)\n{\n\treturn async <V2 = V>(value: V2, ...argv) =>\n\t{\n\t\tawait handler(value as any, ...argv);\n\t\treturn value\n\t}\n}\n\n/**\n * @see https://github.com/sindresorhus/p-tap#ptapcatchtaphandler\n */\nexport function _tapCatchHandler<E extends any = unknown, EC extends Constructor<any> = any>(...inputs: ITapCatchArgvs<EC> | [\n\t((reason: E,\n\t\t...argv: any[]\n\t) => any)\n])\n{\n\treturn async (value, ...argv) =>\n\t{\n\t\tconst handler = inputs.pop() as (reason: any, ...argv: any[]) => any;\n\n\t\tif (!inputs.length || inputs.some((ec) => value instanceof ec))\n\t\t{\n\t\t\tawait handler(value, ...argv);\n\t\t}\n\n\t\treturn Promise.reject(value)\n\t}\n}\n\n/**\n * Essentially like .then(), except that the value passed in is the value returned.\n * @see http://bluebirdjs.com/docs/api/tap.html\n */\nexport function promiseTapThen<P extends Promise<any>, V extends any = Awaited<P>>(promise: P,\n\thandler: (value: V, ...argv: any[]) => any,\n)\n{\n\treturn promise\n\t\t.then(_tapHandler(handler)) as P\n}\n\ntype Constructor<E> = new (...args: any[]) => E;\n\ntype ITapCatchArgvs<EC extends Constructor<unknown>> = [...EC[], (reason: EC, ...argv: any[]) => any];\n\n/**\n * .tapCatch is a convenience method for reacting to errors without handling them with promises - similar to finally but only called on rejections. Useful for logging errors.\n * @see http://bluebirdjs.com/docs/api/tapCatch.html\n */\nexport function promiseTapCatch<P extends Promise<any>, E extends any = unknown, EC extends Constructor<any> = any>(promise: P,\n\t...inputs: ITapCatchArgvs<EC> | [((reason: E, ...argv: any[]) => any)]\n)\n{\n\treturn promise\n\t\t.catch(_tapCatchHandler(...inputs)) as P\n}\n\nexport function promiseTapThenCatch<P extends Promise<any>, V extends any = Awaited<P>, E extends any = unknown>(promise: P,\n\thandlerThen: (value: V, ...argv: any[]) => any,\n\thandlerCatch?: (reason: E, ...argv: any[]) => any,\n): P\n{\n\tpromise = promiseTapThen(promise, handlerThen);\n\n\tif (typeof handlerCatch !== 'undefined')\n\t{\n\t\treturn promiseTapCatch(promise, handlerCatch)\n\t}\n\n\treturn promise\n}\n\nexport function promiseTapLazyBoth<P extends Promise<any>, V extends any = Awaited<P>, E extends any = unknown>(promise: P,\n\thandlerThen: (value: V, ...argv: any[]) => any,\n\thandlerCatch?: (reason: E, ...argv: any[]) => any,\n)\n{\n\treturn promiseTapThenCatch(promise, handlerThen, handlerCatch ?? handlerThen as any)\n}\n\nexport default promiseTapLazyBoth\n"]}