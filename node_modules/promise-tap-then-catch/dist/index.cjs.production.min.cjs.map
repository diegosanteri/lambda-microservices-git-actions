{"version":3,"file":"index.cjs.production.min.cjs","sources":["../src/index.ts"],"sourcesContent":["/**\n * @see https://github.com/sindresorhus/p-tap#ptaptaphandler\n */\nexport function _tapHandler<V extends any>(handler: (value: V, ...argv: any[]) => any)\n{\n\treturn async <V2 = V>(value: V2, ...argv) =>\n\t{\n\t\tawait handler(value as any, ...argv);\n\t\treturn value\n\t}\n}\n\n/**\n * @see https://github.com/sindresorhus/p-tap#ptapcatchtaphandler\n */\nexport function _tapCatchHandler<E extends any = unknown, EC extends Constructor<any> = any>(...inputs: ITapCatchArgvs<EC> | [\n\t((reason: E,\n\t\t...argv: any[]\n\t) => any)\n])\n{\n\treturn async (value, ...argv) =>\n\t{\n\t\tconst handler = inputs.pop() as (reason: any, ...argv: any[]) => any;\n\n\t\tif (!inputs.length || inputs.some((ec) => value instanceof ec))\n\t\t{\n\t\t\tawait handler(value, ...argv);\n\t\t}\n\n\t\treturn Promise.reject(value)\n\t}\n}\n\n/**\n * Essentially like .then(), except that the value passed in is the value returned.\n * @see http://bluebirdjs.com/docs/api/tap.html\n */\nexport function promiseTapThen<P extends Promise<any>, V extends any = Awaited<P>>(promise: P,\n\thandler: (value: V, ...argv: any[]) => any,\n)\n{\n\treturn promise\n\t\t.then(_tapHandler(handler)) as P\n}\n\ntype Constructor<E> = new (...args: any[]) => E;\n\ntype ITapCatchArgvs<EC extends Constructor<unknown>> = [...EC[], (reason: EC, ...argv: any[]) => any];\n\n/**\n * .tapCatch is a convenience method for reacting to errors without handling them with promises - similar to finally but only called on rejections. Useful for logging errors.\n * @see http://bluebirdjs.com/docs/api/tapCatch.html\n */\nexport function promiseTapCatch<P extends Promise<any>, E extends any = unknown, EC extends Constructor<any> = any>(promise: P,\n\t...inputs: ITapCatchArgvs<EC> | [((reason: E, ...argv: any[]) => any)]\n)\n{\n\treturn promise\n\t\t.catch(_tapCatchHandler(...inputs)) as P\n}\n\nexport function promiseTapThenCatch<P extends Promise<any>, V extends any = Awaited<P>, E extends any = unknown>(promise: P,\n\thandlerThen: (value: V, ...argv: any[]) => any,\n\thandlerCatch?: (reason: E, ...argv: any[]) => any,\n): P\n{\n\tpromise = promiseTapThen(promise, handlerThen);\n\n\tif (typeof handlerCatch !== 'undefined')\n\t{\n\t\treturn promiseTapCatch(promise, handlerCatch)\n\t}\n\n\treturn promise\n}\n\nexport function promiseTapLazyBoth<P extends Promise<any>, V extends any = Awaited<P>, E extends any = unknown>(promise: P,\n\thandlerThen: (value: V, ...argv: any[]) => any,\n\thandlerCatch?: (reason: E, ...argv: any[]) => any,\n)\n{\n\treturn promiseTapThenCatch(promise, handlerThen, handlerCatch ?? handlerThen as any)\n}\n\nexport default promiseTapLazyBoth\n"],"names":["value","inputs","async","argv","handler","pop","length","Promise","reject","promiseTapThen","promise","then","_tapHandler","promiseTapCatch","catch","handlerCatch"],"mappings":"4EAGAA,gCAKcC,GAEb,OAAAC,MAAAF,KAAAG,KAWA,MAAAC,EAAYH,EAAYI,MAbvB,OAeAJ,EAAMK,SAAAL,EAAAA,MAAAA,GAAAA,aAAAA,WAENG,EAAAJ,KAAAG,GAjBAI,QAAAC,OAAAR,EAAA,EAwBD,SAAAS,eAAAC,EAAAN,GAMD,OAAgBM,EAqBbC,KAAAC,yBAUFC,gBAAWH,KAAiBT,YAK5Ba,MAAAA,oBAAAA,wCApCD,OA6CCJ,EAAAA,eAAAA,EAAAA,QAAA,IAAAK"}