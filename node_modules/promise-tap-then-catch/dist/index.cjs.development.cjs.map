{"version":3,"file":"index.cjs.development.cjs","sources":["../src/index.ts"],"sourcesContent":["/**\n * @see https://github.com/sindresorhus/p-tap#ptaptaphandler\n */\nexport function _tapHandler<V extends any>(handler: (value: V, ...argv: any[]) => any)\n{\n\treturn async <V2 = V>(value: V2, ...argv) =>\n\t{\n\t\tawait handler(value as any, ...argv);\n\t\treturn value\n\t}\n}\n\n/**\n * @see https://github.com/sindresorhus/p-tap#ptapcatchtaphandler\n */\nexport function _tapCatchHandler<E extends any = unknown, EC extends Constructor<any> = any>(...inputs: ITapCatchArgvs<EC> | [\n\t((reason: E,\n\t\t...argv: any[]\n\t) => any)\n])\n{\n\treturn async (value, ...argv) =>\n\t{\n\t\tconst handler = inputs.pop() as (reason: any, ...argv: any[]) => any;\n\n\t\tif (!inputs.length || inputs.some((ec) => value instanceof ec))\n\t\t{\n\t\t\tawait handler(value, ...argv);\n\t\t}\n\n\t\treturn Promise.reject(value)\n\t}\n}\n\n/**\n * Essentially like .then(), except that the value passed in is the value returned.\n * @see http://bluebirdjs.com/docs/api/tap.html\n */\nexport function promiseTapThen<P extends Promise<any>, V extends any = Awaited<P>>(promise: P,\n\thandler: (value: V, ...argv: any[]) => any,\n)\n{\n\treturn promise\n\t\t.then(_tapHandler(handler)) as P\n}\n\ntype Constructor<E> = new (...args: any[]) => E;\n\ntype ITapCatchArgvs<EC extends Constructor<unknown>> = [...EC[], (reason: EC, ...argv: any[]) => any];\n\n/**\n * .tapCatch is a convenience method for reacting to errors without handling them with promises - similar to finally but only called on rejections. Useful for logging errors.\n * @see http://bluebirdjs.com/docs/api/tapCatch.html\n */\nexport function promiseTapCatch<P extends Promise<any>, E extends any = unknown, EC extends Constructor<any> = any>(promise: P,\n\t...inputs: ITapCatchArgvs<EC> | [((reason: E, ...argv: any[]) => any)]\n)\n{\n\treturn promise\n\t\t.catch(_tapCatchHandler(...inputs)) as P\n}\n\nexport function promiseTapThenCatch<P extends Promise<any>, V extends any = Awaited<P>, E extends any = unknown>(promise: P,\n\thandlerThen: (value: V, ...argv: any[]) => any,\n\thandlerCatch?: (reason: E, ...argv: any[]) => any,\n): P\n{\n\tpromise = promiseTapThen(promise, handlerThen);\n\n\tif (typeof handlerCatch !== 'undefined')\n\t{\n\t\treturn promiseTapCatch(promise, handlerCatch)\n\t}\n\n\treturn promise\n}\n\nexport function promiseTapLazyBoth<P extends Promise<any>, V extends any = Awaited<P>, E extends any = unknown>(promise: P,\n\thandlerThen: (value: V, ...argv: any[]) => any,\n\thandlerCatch?: (reason: E, ...argv: any[]) => any,\n)\n{\n\treturn promiseTapThenCatch(promise, handlerThen, handlerCatch ?? handlerThen as any)\n}\n\nexport default promiseTapLazyBoth\n"],"names":["value","argv","handler","inputs","length","promise","then","_tapHandler","promiseTapCatch","catch"],"mappings":";;;;;;;AAGA,IAAA,OAAA,KAAA,CAAA;;;yBAKE,CAAY,GAAA,MAAZ,EAAY;AAEb,EAAA,OAAA,OAAAA,KAAA,EAAA,GAAAC,IAAA,KAAA;AAWA,IAAA,MAAAC,UAAYC,MAAY,CAAA,GAAZ,EAAZ,CAAA;;AAEC,IAAA,IAAA,CAAA,MAAA,CAAMC,MAAN,IAAMD,MAAAA,CAAAA,IAAAA,CAAAA,EAAAA,IAAAA,KAAAA,YAAAA,EAAAA,CAAN,EAAM;AAEN,MAAA,MAAA,OAAA,CAAA,KAAA,EAAA,GAAA,IAAA,CAAA,CAAA;AAEC,KAAA;;AAnBD,IAAA,OAAA,OAAA,CAAA,MAAA,CAAA,KAAA,CAAA,CAAA;GAED,CAAA;;AAsBA,SAAA,cAAA,CAAA,OAAA,EAAA,OAAA,EAAA;AAMD,EAAA,OAAgBE,OAqBbC,CAAAA,IArBa,CAqBbC,WAAsB,SArBT,CAAhB,CAAA;;SA+BCC,eAAWH,CAAAA,OAAAA,EAAiB,GAAAF,MAC5B,EAAA;gBAEC,CAEDM,KAAAA,CAAAA,gBAAAA,CAAAA,GAAAA,MAAAA,CAAAA,CAAAA,CAAAA;;;AASAJ,EAAAA,OAAAA,GAAAA,cAAAA,CAAAA,OAAAA,EAAAA,WAAAA,CAAAA,CAAAA;;EA7CD,IA6CC,OAAA,YAAA,KAAA,WAAA,EAAA;;;;;;;;;;;;;;;;;;"}